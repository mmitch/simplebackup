#!/usr/bin/perl -w
#
# expirebackups - find old backups to be deleted
#
# 2004-2008 (C) by Christian Garbs <mitch@cgarbs.de>
# Licensed under GNU GPL.
#

use strict;

# parameter handling
die "usage:\n\t$0 [keep_this_many] <backup_path>\n" unless (@ARGV == 1 or @ARGV == 2);
my $keep_count = 4;
if (@ARGV == 2) {
    $keep_count = shift @ARGV;
    die "[keep_this_many] may only contain digits!\n" if ($keep_count =~ y/0-9//c);
}
my ($backup_path) = @ARGV;
$backup_path =~ s:/+$::;

# read file list
my (%backup, @keep, @delete);
opendir DIR, $backup_path or die "can't opendir() `$backup_path': $!\n";
foreach ( grep { -f "$backup_path/$_" } readdir(DIR) ) {
    if ( /^((.+)-(\d{4})(\d{2})(\d{2})\.tar\.bz2)$/ ) {
	push @{$backup{$2}}, {
	    'FILE'  => $1,
	    'NAME'  => $2,
	    'YEAR'  => $3,
	    'MONTH' => $4,
	    'DAY'   => $5,
	    'AGE'   => (($3*13)+$4)*32+$5
	}
    }
}
closedir DIR or die "can't closedir() `$backup_path': $!\n";

foreach my $file (keys %backup) {
    my @backup = @{$backup{$file}};

    # sort newest first
    @backup = sort {$b->{AGE} <=> $a->{AGE}} @backup;
    
    # keep latest 4 entries
    @keep = splice @backup, 0, $keep_count;
    
    # sort oldest first
    @backup = reverse @backup;
    
    # print file list
    print "$backup_path/$_->{FILE}\n" foreach (@backup);
}
